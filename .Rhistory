message("--- Importation des données du Recensement (fichiers locaux) ---")
zip_path_pop_structure <- "data/raw/base-cc-evol-struct-pop-2021_xlsx.zip"
zip_path_activite_reside <- "data/raw/base-ic-activite-residents-2021_xlsx (1).zip"
zip_path_act5 <- "data/raw/TD_ACT5_2021_xlsx.zip"
raw_pop_structure <- import_xlsx_from_zip(zip_path_pop_structure)
raw_ic_activite <- import_xlsx_from_zip(zip_path_activite_reside)
raw_act5 <- import_xlsx_from_zip(zip_path_act5, skip = 9) %>% rename_to_com()
# 2.1 Préparation des données Egapro
egapro_prepared <- prepare_egapro_data(raw_egapro)
# 2.2 Nettoyage des données SIRENE (conservation des sièges sociaux)
sirene_clean <- clean_sirene_data(raw_sirene)
sirene_clean <- sirene_clean %>%
dplyr::mutate(
code_commune = if_else(stringr::str_starts(code_commune, "751"), "75056", code_commune)
)
# 2.3 Calcul des indicateurs socio-démographiques au niveau communal
communes_features <- create_socio_features(
df_pop_structure = raw_pop_structure,
df_ic = raw_ic_activite,
df_act5 = raw_act5
)
paris_commune_data <- communes_features %>% filter(code_commune == "75056")
if(nrow(paris_commune_data) > 0) {
codes_arrondissements <- sprintf("751%02d", 1:20)
paris_arrondissements_data <- paris_commune_data[rep(1, 20), ] %>%
mutate(code_commune = codes_arrondissements)
communes_features <- bind_rows(communes_features, paris_arrondissements_data)
}
# Chargement du fond de carte des communes depuis une source ouverte
map_com_prepared <- load_and_prepare_map()
master_df_historique <- egapro_prepared %>%
# Jointure avec SIRENE pour la localisation
inner_join(sirene_clean, by = "siren") %>%
# Jointure avec les attributs du fond de carte pour récupérer les infos EPT/DEP
inner_join(st_drop_geometry(map_com_prepared), by = c("code_commune" = "com_code")) %>%
# Jointure avec les indicateurs socio-démographiques
left_join(communes_features, by = "code_commune")
message(
"✅ Table 'master_df_historique' finale créée avec ",
scales::comma(nrow(master_df_historique)), " observations."
)
output_dir <- "data_shiny"
if (!dir.exists(output_dir)) dir.create(output_dir)
# 5.1 Sauvegarde de la table de données principale
saveRDS(master_df_historique, file.path(output_dir, "master_df_historique.RDS"))
# 5.2 Sauvegarde des fonds de carte (communes et agrégés)
saveRDS(map_com_prepared, file.path(output_dir, "map_com.RDS"))
map_ept_prepared <- aggregate_map(map_com_prepared, level = "ept")
saveRDS(map_ept_prepared, file.path(output_dir, "map_ept.RDS"))
map_dep_prepared <- aggregate_map(map_com_prepared, level = "dep")
saveRDS(map_dep_prepared, file.path(output_dir, "map_dep.RDS"))
message("✅ Tous les fichiers ont été sauvegardés dans le dossier '", output_dir, "'.")
runApp()
runApp()
runApp()
runApp()
runApp()
runApp()
shiny::runApp()
shiny::runApp()
shiny::runApp()
# Le serveur est celui que tu as fourni, il est déjà parfait.
sectoriel_server <- function(id, master_df_historique, palette_accessible) {
shiny::moduleServer(id, function(input, output, session) {
data_secteur_filtree <- shiny::reactive({
df <- master_df_historique %>%
dplyr::filter(annee == input$filtre_annee_secteur, !is.na(secteur_activite))
if (input$filtre_taille_secteur != "Toutes les tailles") {
df <- df %>% dplyr::filter(tranche_effectifs == input$filtre_taille_secteur)
}
if (isTRUE(input$afficher_tous_secteurs)) {
return(df)
}
if (!is.null(input$filtre_secteurs) && length(input$filtre_secteurs) > 0) {
return(df %>% dplyr::filter(secteur_activite %in% input$filtre_secteurs))
}
sector_summary <- df %>%
dplyr::group_by(secteur_activite) %>%
dplyr::summarise(median_score = stats::median(index, na.rm = TRUE), n = dplyr::n(), .groups = "drop") %>%
dplyr::filter(n >= 10) %>%
dplyr::arrange(dplyr::desc(median_score))
df %>%
dplyr::filter(secteur_activite %in% c(utils::head(sector_summary$secteur_activite, 5), utils::tail(sector_summary$secteur_activite, 5)))
})
plot_height_react <- shiny::reactiveVal(450)
output$plot_sector_ui <- shiny::renderUI({
plotly::plotlyOutput(session$ns("plot_secteur"), height = paste0(plot_height_react(), "px"))
})
output$plot_secteur <- plotly::renderPlotly({
df_plot <- data_secteur_filtree()
shiny::req(nrow(df_plot) > 0, cancelOutput = TRUE)
sector_summary <- df_plot %>%
dplyr::group_by(secteur_activite) %>%
dplyr::summarise(score_median = stats::median(index, na.rm = TRUE), .groups = "drop") %>%
dplyr::arrange(score_median)
default_palette <- c("#7B61FF", "#495057", "#20C997", "#FD7E14", "#FFC107")
palette_a_utiliser <- if (isTRUE(input$color_switch_secteur)) {
palette_accessible
} else {
default_palette
}
n_cols <- dplyr::n_distinct(sector_summary$secteur_activite)
palette_cols <- rep(palette_a_utiliser, length.out = n_cols)
sector_summary$col <- palette_cols
plot_height <- max(400, 35 * nrow(sector_summary))
left_margin <- max(150, 7 * max(nchar(sector_summary$secteur_activite)))
plot_height_react(plot_height)
g <- ggplot2::ggplot(sector_summary,
ggplot2::aes(x = score_median,
y = reorder(stringr::str_wrap(secteur_activite, 40), score_median),
text = sprintf("<b>Secteur :</b> %s<br><b>Médiane :</b> %.1f",
secteur_activite, score_median))) +
ggplot2::geom_segment(ggplot2::aes(x = 0, xend = score_median,
yend = reorder(stringr::str_wrap(secteur_activite, 40), score_median)),
linewidth = 1.5, colour = "#CED4DA") +
ggplot2::geom_point(size = 7, aes(fill = col), shape = 21, colour = "#495057", stroke = 1) +
ggplot2::geom_vline(xintercept = 85, linetype = "dashed",
linewidth = 1, colour = "#DC3545") +
ggplot2::scale_fill_identity() +
ggplot2::guides(fill = "none") +
ggplot2::labs(x = "Score Egapro (médiane)", y = NULL) +
ggplot2::theme_minimal(base_family = "Inter") +
ggplot2::theme(
panel.grid.major.y = ggplot2::element_blank(),
panel.grid.minor.x = ggplot2::element_blank(),
axis.text.y = ggplot2::element_text(face = "bold")
)
g %>%
plotly::ggplotly(tooltip = "text") %>%
plotly::layout(margin = list(l = left_margin, t = 30, r = 20, b = 40),
height = plot_height) %>%
plotly::config(displayModeBar = FALSE)
})
output$table_secteur <- DT::renderDataTable({
summary_df <- data_secteur_filtree() %>%
dplyr::group_by(secteur_activite) %>%
dplyr::summarise(`Nb entreprises` = dplyr::n(),
`Score Moyen`    = mean(index,  na.rm = TRUE),
`Score Médian`   = stats::median(index, na.rm = TRUE),
`% < 85`         = mean(index < 85, na.rm = TRUE),
.groups          = "drop") %>%
dplyr::arrange(dplyr::desc(`Score Moyen`))
summary_df %>%
DT::datatable(rownames = FALSE, extensions = "Buttons",
options  = list(pageLength = 10, dom = "Bfrtip",
buttons   = list("copy", "csv", "excel"),
language  = list(url = "//cdn.datatables.net/plug-ins/1.13.4/i18n/fr-FR.json"))) %>%
DT::formatRound(columns = 2,   digits = 0) %>%
DT::formatRound(columns = 3:4, digits = 1) %>%
DT::formatPercentage(columns = 5, digits = 1)
})
})
}
shiny::runApp()
shiny::runApp()
shiny::runApp()
shiny::runApp()
shiny::runApp()
shiny::runApp()
shiny::runApp()
shiny::runApp()
shiny::runApp()
runApp()
shiny::runApp()
socio_dem_server <- function(id, master_df_historique, socio_variable_labels) {
shiny::moduleServer(id, function(input, output, session) {
data_sd <- shiny::reactive({
master_df_historique %>%
dplyr::filter(
annee == input$filtre_annee_socio,
if (length(input$filtre_ept_sd) > 0)
ept_name %in% input$filtre_ept_sd else TRUE
) %>%
dplyr::group_by(ept_name) %>%
dplyr::summarise(
score_moyen = weighted.mean(index, poids, na.rm = TRUE),
socio_val   = mean(.data[[input$socio_variable]], na.rm = TRUE),
n           = dplyr::n(),
.groups     = "drop"
) %>%
dplyr::filter(is.finite(score_moyen) & is.finite(socio_val))
})
output$titre_socio_ui <- shiny::renderUI({
shiny::HTML(paste("Score Egapro moyen vs.", socio_variable_labels[input$socio_variable]))
})
# --- GRAPHIQUE CORRIGÉ : RÉINTÉGRATION DES LABELS ---
output$plot_socio_interactif <- plotly::renderPlotly({
df <- data_sd()
shiny::validate(shiny::need(nrow(df) > 1, "Données insuffisantes pour tracer une relation."))
# On recrée le graphique avec ggplot2 pour bénéficier de ggrepel
g <- ggplot2::ggplot(df, ggplot2::aes(x = socio_val, y = score_moyen,
size = n,
label = ept_name, # On ajoute l'esthétique 'label'
text = paste0( # On crée le tooltip
"<b>Territoire :</b> ", ept_name,
"<br><b>Score Egapro moyen :</b> ", round(score_moyen, 1),
"<br><b>", stringr::str_trunc(socio_variable_labels[input$socio_variable], 30), " :</b> ", round(socio_val, 1), "%",
"<br><b>Nb d'entreprises :</b> ", n
))) +
# La ligne de régression est de retour
ggplot2::geom_smooth(method = "lm", se = FALSE, colour = "#DC3545", linetype = "dashed", linewidth = 0.8, aes(weight = n), inherit.aes = FALSE, aes(x=socio_val, y=score_moyen)) +
# Les points
ggplot2::geom_point(colour = "#7B61FF", alpha = 0.7) +
# Les étiquettes des territoires
ggrepel::geom_text_repel(force = 2, max.overlaps = Inf) +
ggplot2::labs(
x = socio_variable_labels[input$socio_variable],
y = "Score Egapro moyen pondéré",
size = "Nb d'entreprises"
) +
ggplot2::theme_minimal(base_family = "Inter") +
ggplot2::coord_cartesian(ylim = c(80, 100))
# On convertit le ggplot final en plotly
plotly::ggplotly(g, tooltip = "text") %>%
plotly::layout(
legend = list(orientation = 'h', y = -0.2, x = 0.5, xanchor = 'center')
) %>%
plotly::config(displayModeBar = FALSE)
})
output$corr_banner <- shiny::renderUI({
df <- data_sd()
if (nrow(df) < 3) return(NULL)
ct <- stats::cor.test(df$socio_val, df$score_moyen)
r  <- round(ct$estimate, 2)
p  <- ct$p.value
couleur_bg <- dplyr::case_when(p < .05 & r > 0 ~ "#d1f3e0",
p < .05 & r < 0 ~ "#f8d7da",
TRUE          ~ "#e9ecef")
couleur_text <- dplyr::case_when(p < .05 & r > 0 ~ "#0a3622",
p < .05 & r < 0 ~ "#58151c",
TRUE          ~ "#495057")
tendance <- dplyr::case_when(r >  .4 ~ "positive marquée", r >  .15~ "positive faible", r < -.4 ~ "négative marquée", r < -.15~ "négative faible", TRUE    ~ "quasi nulle")
shiny::div(
style = paste0(
"background-color:", couleur_bg,
"; color:", couleur_text,
"; padding:12px; font-weight:600; border-radius:8px; margin-top:15px; text-align:center;"
),
paste0("Corrélation de Pearson : ", r, " (p-value = ", formatC(p, digits = 3, format = "f"), "). Tendance ", tendance, ".")
)
})
output$table_sd <- DT::renderDT({
master_df_historique %>%
dplyr::filter(annee == input$filtre_annee_socio, if (length(input$filtre_ept_sd) > 0) ept_name %in% input$filtre_ept_sd else TRUE) %>%
dplyr::summarise(
`Taux activité F` = mean(taux_activite_femmes, na.rm = TRUE),
`Femmes cadres` = mean(part_femmes_cadres, na.rm = TRUE),
`Femmes prof. inter.` = mean(part_femmes_prof_inter, na.rm = TRUE),
`Taux féminisation cadres` = mean(taux_femmes_parmi_cadres,  na.rm = TRUE), .groups = "drop") %>%
tidyr::pivot_longer(everything(), names_to  = "Indicateur", values_to = "Valeur") %>%
dplyr::mutate(Valeur = sprintf("%.1f %%", Valeur)) %>%
DT::datatable(options = list(dom = "t"), rownames = FALSE)
})
output$alert_paris_sd <- shiny::renderUI({
if ("Ville de Paris" %in% input$filtre_ept_sd) {
shiny::tags$div(style = "margin-top:8px; font-size: 0.85em; color:#8a6d3b; background:#fcf8e3; border:1px solid #faebcc; border-radius:4px; padding:6px;",
shiny::icon("info-circle"),
shiny::HTML("La <strong>Ville de Paris</strong> ne dispose pas<br> de données socio-démographiques<br> (sauf taux de féminisation des cadres).<br> Son inclusion peut biaiser les distributions<br> et les corrélations."))
} else { NULL }
})
})
}
runApp()
runApp()
runApp()
shiny::runApp()
shiny::runApp()
shiny::runApp()
shiny::runApp()
runApp()
install.packages("writexl")
shiny::runApp()
shiny::runApp()
shiny::runApp()
shiny::runApp()
shiny::runApp()
runApp()
shiny::runApp()
knitr::opts_chunk$set(echo = TRUE, message = TRUE, warning = TRUE)
# Librairies nécessaires pour ce script
library(dplyr)
library(sf)
library(stringr)
library(readxl)
# Fonctions de préparation personnalisées
source("R/utils.R")
# 1.1 Egapro (via API data.gouv.fr)
raw_egapro <- import_latest_egapro()
# 1.2 SIRENE (via API Opendatasoft pour l'IDF)
raw_sirene <- import_sirene_idf()
# 1.3 Données du Recensement de la Population 2021 (INSEE)
message("--- Importation des données du Recensement (fichiers locaux) ---")
zip_path_pop_structure <- "data/raw/base-cc-evol-struct-pop-2021_xlsx.zip"
zip_path_activite_reside <- "data/raw/base-ic-activite-residents-2021_xlsx (1).zip"
zip_path_act5 <- "data/raw/TD_ACT5_2021_xlsx.zip"
raw_pop_structure <- import_xlsx_from_zip(zip_path_pop_structure)
raw_ic_activite <- import_xlsx_from_zip(zip_path_activite_reside)
raw_act5 <- import_xlsx_from_zip(zip_path_act5, skip = 9) %>% rename_to_com()
# 2.1 Préparation des données Egapro
egapro_prepared <- prepare_egapro_data(raw_egapro)
# 2.2 Nettoyage des données SIRENE (conservation des sièges sociaux)
sirene_clean <- clean_sirene_data(raw_sirene)
sirene_clean <- sirene_clean %>%
dplyr::mutate(
code_commune = if_else(stringr::str_starts(code_commune, "751"), "75056", code_commune)
)
# 2.3 Calcul des indicateurs socio-démographiques au niveau communal
communes_features <- create_socio_features(
df_pop_structure = raw_pop_structure,
df_ic = raw_ic_activite,
df_act5 = raw_act5
)
paris_commune_data <- communes_features %>% filter(code_commune == "75056")
if(nrow(paris_commune_data) > 0) {
codes_arrondissements <- sprintf("751%02d", 1:20)
paris_arrondissements_data <- paris_commune_data[rep(1, 20), ] %>%
mutate(code_commune = codes_arrondissements)
communes_features <- bind_rows(communes_features, paris_arrondissements_data)
}
# Chargement du fond de carte des communes depuis une source ouverte
map_com_prepared <- load_and_prepare_map()
# CORRECTIF CRUCIAL : s'assurer que ze_code est bien une colonne
# et non une liste-colonne qui pose problème ensuite.
map_com_prepared <- map_com_prepared %>%
dplyr::mutate(ze_code = as.character(ze_code))
# Étape A : Créer les features socio-démographiques par commune
communes_socio_features <- create_socio_features(
df_pop_structure = raw_pop_structure,
df_ic = raw_ic_activite,
df_act5 = raw_act5
)
# Étape B : Les agréger par Zone d'Emploi
ze_socio_features <- aggregate_socio_to_ze(communes_socio_features)
# Étape C : Construction de la table finale
master_df_historique <- egapro_prepared %>%
# Jointure avec SIRENE pour la localisation
inner_join(sirene_clean, by = "siren") %>%
# Jointure avec les attributs du fond de carte pour récupérer EPT/DEP/ZE
inner_join(st_drop_geometry(map_com_prepared), by = c("code_commune" = "com_code")) %>%
# JOINTURE FINALE ET UNIQUE : On joint les données socio-démographiques
# DÉJÀ agrégées par Zone d'Emploi.
left_join(ze_socio_features, by = "ze_code")
message(
"✅ Table 'master_df_historique' finale créée avec ",
scales::comma(nrow(master_df_historique)), " observations."
)
output_dir <- "data_shiny"
if (!dir.exists(output_dir)) dir.create(output_dir)
# 5.1 Sauvegarde de la table de données principale
saveRDS(master_df_historique, file.path(output_dir, "master_df_historique.RDS"))
# 5.2 Sauvegarde des fonds de carte (communes et agrégés)
saveRDS(map_com_prepared, file.path(output_dir, "map_com.RDS"))
map_ept_prepared <- aggregate_map(map_com_prepared, level = "ept")
saveRDS(map_ept_prepared, file.path(output_dir, "map_ept.RDS"))
map_dep_prepared <- aggregate_map(map_com_prepared, level = "dep")
saveRDS(map_dep_prepared, file.path(output_dir, "map_dep.RDS"))
# --- ORDRE NOUVEAU ---: Création et sauvegarde du fond de carte pour les Zones d'Emploi
map_ze_prepared <- aggregate_map(map_com_prepared, level = "ze")
saveRDS(map_ze_prepared, file.path(output_dir, "map_ze.RDS"))
message("✅ Tous les fichiers ont été sauvegardés dans le dossier '", output_dir, "'.")
shiny::runApp()
knitr::opts_chunk$set(echo = TRUE, message = TRUE, warning = TRUE)
# Librairies nécessaires pour ce script
library(dplyr)
library(sf)
library(stringr)
library(readxl)
# Fonctions de préparation personnalisées
source("R/utils.R")
# 1.1 Egapro (via API data.gouv.fr)
raw_egapro <- import_latest_egapro()
# 1.2 SIRENE (via API Opendatasoft pour l'IDF)
raw_sirene <- import_sirene_idf()
# 1.3 Données du Recensement de la Population 2021 (INSEE)
message("--- Importation des données du Recensement (fichiers locaux) ---")
zip_path_pop_structure <- "data/raw/base-cc-evol-struct-pop-2021_xlsx.zip"
zip_path_activite_reside <- "data/raw/base-ic-activite-residents-2021_xlsx (1).zip"
zip_path_act5 <- "data/raw/TD_ACT5_2021_xlsx.zip"
raw_pop_structure <- import_xlsx_from_zip(zip_path_pop_structure)
raw_ic_activite <- import_xlsx_from_zip(zip_path_activite_reside)
raw_act5 <- import_xlsx_from_zip(zip_path_act5, skip = 9) %>% rename_to_com()
# 2.1 Préparation des données Egapro
egapro_prepared <- prepare_egapro_data(raw_egapro)
# 2.2 Nettoyage des données SIRENE (conservation des sièges sociaux)
sirene_clean <- clean_sirene_data(raw_sirene)
sirene_clean <- sirene_clean %>%
dplyr::mutate(
code_commune = if_else(stringr::str_starts(code_commune, "751"), "75056", code_commune)
)
# 2.3 Calcul des indicateurs socio-démographiques au niveau communal
communes_features <- create_socio_features(
df_pop_structure = raw_pop_structure,
df_ic = raw_ic_activite,
df_act5 = raw_act5
)
paris_commune_data <- communes_features %>% filter(code_commune == "75056")
if(nrow(paris_commune_data) > 0) {
codes_arrondissements <- sprintf("751%02d", 1:20)
paris_arrondissements_data <- paris_commune_data[rep(1, 20), ] %>%
mutate(code_commune = codes_arrondissements)
communes_features <- bind_rows(communes_features, paris_arrondissements_data)
}
# Chargement du fond de carte des communes depuis une source ouverte
map_com_prepared <- load_and_prepare_map()
map_com_prepared <- map_com_prepared %>%
dplyr::mutate(ze_code = as.character(ze_code))
# ÉTAPE CORRIGÉE : Créer les features agrégées par Zone d'Emploi
ze_socio_features <- aggregate_socio_to_ze(communes_features)
master_df_historique <- egapro_prepared %>%
# Jointure avec SIRENE pour la localisation
inner_join(sirene_clean, by = "siren") %>%
# Jointure avec les attributs du fond de carte pour récupérer les infos EPT/DEP/ZE
inner_join(st_drop_geometry(map_com_prepared), by = c("code_commune" = "com_code")) %>%
# ACTION FINALE : JOINTURE UNIQUE ET DÉFINITIVE AVEC LES DONNÉES PAR ZONE D'EMPLOI
# C'est la seule source de données socio-démographiques pour notre analyse.
left_join(ze_socio_features, by = "ze_code")
message(
"✅ Table 'master_df_historique' finale créée avec ",
scales::comma(nrow(master_df_historique)), " observations."
)
output_dir <- "data_shiny"
if (!dir.exists(output_dir)) dir.create(output_dir)
# 5.1 Sauvegarde de la table de données principale
saveRDS(master_df_historique, file.path(output_dir, "master_df_historique.RDS"))
# 5.2 Sauvegarde des fonds de carte (communes et agrégés)
saveRDS(map_com_prepared, file.path(output_dir, "map_com.RDS"))
map_ept_prepared <- aggregate_map(map_com_prepared, level = "ept")
saveRDS(map_ept_prepared, file.path(output_dir, "map_ept.RDS"))
map_dep_prepared <- aggregate_map(map_com_prepared, level = "dep")
saveRDS(map_dep_prepared, file.path(output_dir, "map_dep.RDS"))
# --- ORDRE NOUVEAU ---: Création et sauvegarde du fond de carte pour les Zones d'Emploi
map_ze_prepared <- aggregate_map(map_com_prepared, level = "ze")
saveRDS(map_ze_prepared, file.path(output_dir, "map_ze.RDS"))
message("✅ Tous les fichiers ont été sauvegardés dans le dossier '", output_dir, "'.")
knitr::opts_chunk$set(echo = TRUE, message = TRUE, warning = TRUE)
# Librairies nécessaires pour ce script
library(dplyr)
library(sf)
library(stringr)
library(readxl)
# Fonctions de préparation personnalisées
source("R/utils.R")
# 1.1 Egapro (via API data.gouv.fr)
raw_egapro <- import_latest_egapro()
# 1.2 SIRENE (via API Opendatasoft pour l'IDF)
raw_sirene <- import_sirene_idf()
# 1.3 Données du Recensement de la Population 2021 (INSEE)
message("--- Importation des données du Recensement (fichiers locaux) ---")
zip_path_pop_structure <- "data/raw/base-cc-evol-struct-pop-2021_xlsx.zip"
zip_path_activite_reside <- "data/raw/base-ic-activite-residents-2021_xlsx (1).zip"
zip_path_act5 <- "data/raw/TD_ACT5_2021_xlsx.zip"
raw_pop_structure <- import_xlsx_from_zip(zip_path_pop_structure)
raw_ic_activite <- import_xlsx_from_zip(zip_path_activite_reside)
raw_act5 <- import_xlsx_from_zip(zip_path_act5, skip = 9) %>% rename_to_com()
# 2.1 Préparation des données Egapro
egapro_prepared <- prepare_egapro_data(raw_egapro)
# 2.2 Nettoyage des données SIRENE (conservation des sièges sociaux)
sirene_clean <- clean_sirene_data(raw_sirene)
sirene_clean <- sirene_clean %>%
dplyr::mutate(
code_commune = if_else(stringr::str_starts(code_commune, "751"), "75056", code_commune)
)
# 2.3 Calcul des indicateurs socio-démographiques au niveau communal
communes_features <- create_socio_features(
df_pop_structure = raw_pop_structure,
df_ic = raw_ic_activite,
df_act5 = raw_act5
)
paris_commune_data <- communes_features %>% filter(code_commune == "75056")
if(nrow(paris_commune_data) > 0) {
codes_arrondissements <- sprintf("751%02d", 1:20)
paris_arrondissements_data <- paris_commune_data[rep(1, 20), ] %>%
mutate(code_commune = codes_arrondissements)
communes_features <- bind_rows(communes_features, paris_arrondissements_data)
}
# Chargement du fond de carte des communes depuis une source ouverte
map_com_prepared <- load_and_prepare_map()
map_com_prepared <- map_com_prepared %>%
dplyr::mutate(ze_code = as.character(ze_code))
# ÉTAPE CORRIGÉE : Créer les features agrégées par Zone d'Emploi
ze_socio_features <- aggregate_socio_to_ze(communes_features)
master_df_historique <- egapro_prepared %>%
# Jointure avec SIRENE pour la localisation
inner_join(sirene_clean, by = "siren") %>%
# Jointure avec les attributs du fond de carte pour récupérer les infos EPT/DEP/ZE
inner_join(st_drop_geometry(map_com_prepared), by = c("code_commune" = "com_code")) %>%
# ACTION FINALE : JOINTURE UNIQUE ET DÉFINITIVE AVEC LES DONNÉES PAR ZONE D'EMPLOI
# C'est la seule source de données socio-démographiques pour notre analyse.
left_join(ze_socio_features, by = "ze_code")
message(
"✅ Table 'master_df_historique' finale créée avec ",
scales::comma(nrow(master_df_historique)), " observations."
)
output_dir <- "data_shiny"
if (!dir.exists(output_dir)) dir.create(output_dir)
# 5.1 Sauvegarde de la table de données principale
saveRDS(master_df_historique, file.path(output_dir, "master_df_historique.RDS"))
# 5.2 Sauvegarde des fonds de carte (communes et agrégés)
saveRDS(map_com_prepared, file.path(output_dir, "map_com.RDS"))
map_ept_prepared <- aggregate_map(map_com_prepared, level = "ept")
saveRDS(map_ept_prepared, file.path(output_dir, "map_ept.RDS"))
map_dep_prepared <- aggregate_map(map_com_prepared, level = "dep")
saveRDS(map_dep_prepared, file.path(output_dir, "map_dep.RDS"))
# --- ORDRE NOUVEAU ---: Création et sauvegarde du fond de carte pour les Zones d'Emploi
map_ze_prepared <- aggregate_map(map_com_prepared, level = "ze")
saveRDS(map_ze_prepared, file.path(output_dir, "map_ze.RDS"))
message("✅ Tous les fichiers ont été sauvegardés dans le dossier '", output_dir, "'.")
runApp()
runApp()
runApp()
runApp()
runApp()

df_pop_structure = raw_pop_structure,
df_ic = raw_ic_activite,
df_act5 = raw_act5
)
paris_commune_data <- communes_features %>% filter(code_commune == "75056")
if(nrow(paris_commune_data) > 0) {
codes_arrondissements <- sprintf("751%02d", 1:20)
paris_arrondissements_data <- paris_commune_data[rep(1, 20), ] %>%
mutate(code_commune = codes_arrondissements)
communes_features <- bind_rows(communes_features, paris_arrondissements_data)
message("✅ Données socio-démographiques de Paris dupliquées pour les 20 arrondissements.")
}
# Chargement du fond de carte des communes depuis une source ouverte
map_com_prepared <- load_and_prepare_map()
master_df_historique <- egapro_prepared %>%
# Jointure avec SIRENE pour la localisation
inner_join(sirene_clean, by = "siren") %>%
# Jointure avec les attributs du fond de carte pour récupérer les infos EPT/DEP
inner_join(st_drop_geometry(map_com_prepared), by = c("code_commune" = "com_code")) %>%
# Jointure avec les indicateurs socio-démographiques
left_join(communes_features, by = "code_commune")
message(
"✅ Table 'master_df_historique' finale créée avec ",
scales::comma(nrow(master_df_historique)), " observations."
)
output_dir <- "data_shiny"
if (!dir.exists(output_dir)) dir.create(output_dir)
# 5.1 Sauvegarde de la table de données principale
saveRDS(master_df_historique, file.path(output_dir, "master_df_historique.RDS"))
# 5.2 Sauvegarde des fonds de carte (communes et agrégés)
saveRDS(map_com_prepared, file.path(output_dir, "map_com.RDS"))
map_ept_prepared <- aggregate_map(map_com_prepared, level = "ept")
saveRDS(map_ept_prepared, file.path(output_dir, "map_ept.RDS"))
map_dep_prepared <- aggregate_map(map_com_prepared, level = "dep")
saveRDS(map_dep_prepared, file.path(output_dir, "map_dep.RDS"))
message("✅ Tous les fichiers ont été sauvegardés dans le dossier '", output_dir, "'.")
runApp()
install.packages("rsconnect")
rsconnect::setAccountInfo(name='alespfer', token='1986C654FD8B9D5FEC246D8882E33054', secret='emXOyPvNvHgwZNfrrG8tKGiyIse4j32zidUXDIxh')
setwd("~/Desktop/PROJET_SHINY_RENDU")
rsconnect::deployApp(appName = "barometre-egapro")
runApp('~/egapro')
rsconnect::deployApp(appName = "barometre-egapro")
setwd("~/egapro")
setwd("~/Desktop/PROJET_SHINY_RENDU")
rsconnect::deployApp(appName="barometre-egapro")
runApp('~/egapro')
runApp('~/egapro')
runApp('~/egapro')
runApp('~/egapro')
runApp('~/egapro')
runApp('~/egapro')
runApp('~/egapro')
runApp('~/egapro')
setwd("~/Desktop/PROJET_EGAPRO")
rsconnect::deployApp(appName = "barometre-parite-paris")
runApp('~/egapro')
runApp('~/egapro')
knitr::opts_chunk$set(echo = TRUE, message = TRUE, warning = TRUE)
# Librairies nécessaires pour ce script
library(dplyr)
library(sf)
library(stringr)
library(readxl)
# Fonctions de préparation personnalisées
source("utils.R")
# 1.1 Egapro (via API data.gouv.fr)
raw_egapro <- import_latest_egapro()
# 1.2 SIRENE (via API Opendatasoft pour l'IDF)
raw_sirene <- import_sirene_idf()
# 1.3 Données du Recensement de la Population 2021 (INSEE)
message("--- Importation des données du Recensement (fichiers locaux) ---")
zip_path_pop_structure <- "data/raw/base-cc-evol-struct-pop-2021_xlsx.zip"
zip_path_activite_reside <- "data/raw/base-ic-activite-residents-2021_xlsx (1).zip"
zip_path_act5 <- "data/raw/TD_ACT5_2021_xlsx.zip"
raw_pop_structure <- import_xlsx_from_zip(zip_path_pop_structure)
raw_ic_activite <- import_xlsx_from_zip(zip_path_activite_reside)
raw_act5 <- import_xlsx_from_zip(zip_path_act5, skip = 9) %>% rename_to_com()
# 2.1 Préparation des données Egapro
egapro_prepared <- prepare_egapro_data(raw_egapro)
# 2.2 Nettoyage des données SIRENE (conservation des sièges sociaux)
sirene_clean <- clean_sirene_data(raw_sirene)
# 2.3 Calcul des indicateurs socio-démographiques au niveau communal
communes_features <- create_socio_features(
df_pop_structure = raw_pop_structure,
df_ic = raw_ic_activite,
df_act5 = raw_act5
)
# Chargement du fond de carte des communes depuis une source ouverte
map_com_prepared <- load_and_prepare_map()
knitr::opts_chunk$set(echo = TRUE, message = TRUE, warning = TRUE)
# Librairies nécessaires pour ce script
library(dplyr)
library(sf)
library(stringr)
library(readxl)
# Fonctions de préparation personnalisées
source("utils.R")
# 1.1 Egapro (via API data.gouv.fr)
raw_egapro <- import_latest_egapro()
# 1.2 SIRENE (via API Opendatasoft pour l'IDF)
raw_sirene <- import_sirene_idf()
# 1.3 Données du Recensement de la Population 2021 (INSEE)
message("--- Importation des données du Recensement (fichiers locaux) ---")
zip_path_pop_structure <- "data/raw/base-cc-evol-struct-pop-2021_xlsx.zip"
zip_path_activite_reside <- "data/raw/base-ic-activite-residents-2021_xlsx (1).zip"
zip_path_act5 <- "data/raw/TD_ACT5_2021_xlsx.zip"
raw_pop_structure <- import_xlsx_from_zip(zip_path_pop_structure)
raw_ic_activite <- import_xlsx_from_zip(zip_path_activite_reside)
raw_act5 <- import_xlsx_from_zip(zip_path_act5, skip = 9) %>% rename_to_com()
# 2.1 Préparation des données Egapro
egapro_prepared <- prepare_egapro_data(raw_egapro)
# 2.2 Nettoyage des données SIRENE (conservation des sièges sociaux)
sirene_clean <- clean_sirene_data(raw_sirene)
# 2.3 Calcul des indicateurs socio-démographiques au niveau communal
communes_features <- create_socio_features(
df_pop_structure = raw_pop_structure,
df_ic = raw_ic_activite,
df_act5 = raw_act5
)
# Chargement du fond de carte des communes depuis une source ouverte
map_com_prepared <- load_and_prepare_map()
master_df_historique <- egapro_prepared %>%
inner_join(sirene_clean, by = "siren") %>%
mutate(
code_commune = if_else(str_starts(code_commune, "751"), "75056", code_commune)
) %>%
inner_join(st_drop_geometry(map_com_prepared), by = c("code_commune" = "com_code")) %>%
left_join(communes_features, by = "code_commune")
message(
"✅ Table 'master_df_historique' finale créée avec ",
scales::comma(nrow(master_df_historique)), " observations."
)
output_dir <- "data_shiny"
if (!dir.exists(output_dir)) dir.create(output_dir)
# 5.1 Sauvegarde de la table de données principale
saveRDS(master_df_historique, file.path(output_dir, "master_df_historique.RDS"))
# 5.2 Sauvegarde des fonds de carte (communes et agrégés)
saveRDS(map_com_prepared, file.path(output_dir, "map_com.RDS"))
map_ept_prepared <- aggregate_map(map_com_prepared, level = "ept")
saveRDS(map_ept_prepared, file.path(output_dir, "map_ept.RDS"))
map_dep_prepared <- aggregate_map(map_com_prepared, level = "dep")
saveRDS(map_dep_prepared, file.path(output_dir, "map_dep.RDS"))
message("✅ Tous les fichiers ont été sauvegardés dans le dossier '", output_dir, "'.")
View(master_df_historique)
# 2.1 Préparation des données Egapro
egapro_prepared <- prepare_egapro_data(raw_egapro)
# 2.2 Nettoyage des données SIRENE (conservation des sièges sociaux)
sirene_clean <- clean_sirene_data(raw_sirene)
# 2.3 Calcul des indicateurs socio-démographiques au niveau communal
communes_features <- create_socio_features(
df_pop_structure = raw_pop_structure,
df_ic = raw_ic_activite,
df_act5 = raw_act5
)
paris_commune_data <- communes_features %>% filter(code_commune == "75056")
if(nrow(paris_commune_data) > 0) {
codes_arrondissements <- sprintf("751%02d", 1:20)
paris_arrondissements_data <- paris_commune_data[rep(1, 20), ] %>%
mutate(code_commune = codes_arrondissements)
communes_features <- bind_rows(communes_features, paris_arrondissements_data)
}
# Chargement du fond de carte des communes depuis une source ouverte
map_com_prepared <- load_and_prepare_map()
master_df_historique <- egapro_prepared %>%
# Jointure avec SIRENE pour la localisation
inner_join(sirene_clean, by = "siren") %>%
# Jointure avec les attributs du fond de carte pour récupérer les infos EPT/DEP
inner_join(st_drop_geometry(map_com_prepared), by = c("code_commune" = "com_code")) %>%
# Jointure avec les indicateurs socio-démographiques
left_join(communes_features, by = "code_commune")
message(
"✅ Table 'master_df_historique' finale créée avec ",
scales::comma(nrow(master_df_historique)), " observations."
)
runApp('~/egapro')
# Librairies nécessaires pour ce script
library(dplyr)
library(sf)
library(stringr)
library(readxl)
# Fonctions de préparation personnalisées
source("utils.R")
# 1.1 Egapro (via API data.gouv.fr)
raw_egapro <- import_latest_egapro()
# 1.2 SIRENE (via API Opendatasoft pour l'IDF)
raw_sirene <- import_sirene_idf()
# 1.3 Données du Recensement de la Population 2021 (INSEE)
message("--- Importation des données du Recensement (fichiers locaux) ---")
zip_path_pop_structure <- "data/raw/base-cc-evol-struct-pop-2021_xlsx.zip"
zip_path_activite_reside <- "data/raw/base-ic-activite-residents-2021_xlsx (1).zip"
zip_path_act5 <- "data/raw/TD_ACT5_2021_xlsx.zip"
raw_pop_structure <- import_xlsx_from_zip(zip_path_pop_structure)
raw_ic_activite <- import_xlsx_from_zip(zip_path_activite_reside)
raw_act5 <- import_xlsx_from_zip(zip_path_act5, skip = 9) %>% rename_to_com()
# 2.1 Préparation des données Egapro
egapro_prepared <- prepare_egapro_data(raw_egapro)
# 2.2 Nettoyage des données SIRENE (conservation des sièges sociaux)
sirene_clean <- clean_sirene_data(raw_sirene)
# 2.3 Calcul des indicateurs socio-démographiques au niveau communal
communes_features <- create_socio_features(
df_pop_structure = raw_pop_structure,
df_ic = raw_ic_activite,
df_act5 = raw_act5
)
paris_commune_data <- communes_features %>% filter(code_commune == "75056")
if(nrow(paris_commune_data) > 0) {
codes_arrondissements <- sprintf("751%02d", 1:20)
paris_arrondissements_data <- paris_commune_data[rep(1, 20), ] %>%
mutate(code_commune = codes_arrondissements)
communes_features <- bind_rows(communes_features, paris_arrondissements_data)
}
# Chargement du fond de carte des communes depuis une source ouverte
map_com_prepared <- load_and_prepare_map()
master_df_historique <- egapro_prepared %>%
# Jointure avec SIRENE pour la localisation
inner_join(sirene_clean, by = "siren") %>%
# Jointure avec les attributs du fond de carte pour récupérer les infos EPT/DEP
inner_join(st_drop_geometry(map_com_prepared), by = c("code_commune" = "com_code")) %>%
# Jointure avec les indicateurs socio-démographiques
left_join(communes_features, by = "code_commune")
message(
"✅ Table 'master_df_historique' finale créée avec ",
scales::comma(nrow(master_df_historique)), " observations."
)
output_dir <- "data_shiny"
if (!dir.exists(output_dir)) dir.create(output_dir)
# 5.1 Sauvegarde de la table de données principale
saveRDS(master_df_historique, file.path(output_dir, "master_df_historique.RDS"))
# 5.2 Sauvegarde des fonds de carte (communes et agrégés)
saveRDS(map_com_prepared, file.path(output_dir, "map_com.RDS"))
map_ept_prepared <- aggregate_map(map_com_prepared, level = "ept")
saveRDS(map_ept_prepared, file.path(output_dir, "map_ept.RDS"))
map_dep_prepared <- aggregate_map(map_com_prepared, level = "dep")
saveRDS(map_dep_prepared, file.path(output_dir, "map_dep.RDS"))
message("✅ Tous les fichiers ont été sauvegardés dans le dossier '", output_dir, "'.")
runApp('~/egapro')
runApp('~/egapro')
knitr::opts_chunk$set(echo = TRUE, message = TRUE, warning = TRUE)
# Librairies nécessaires pour ce script
library(dplyr)
library(sf)
library(stringr)
library(readxl)
library(janitor)
# Fonctions de préparation personnalisées
source("utils.R")
# 1.1 Egapro (via API data.gouv.fr)
raw_egapro <- import_latest_egapro()
# 1.2 SIRENE (via API Opendatasoft pour l'IDF)
raw_sirene <- import_sirene_idf()
# 1.3 Données du Recensement de la Population 2021 (INSEE)
message("--- Importation des données du Recensement (fichiers locaux) ---")
zip_path_pop_structure <- "data/raw/base-cc-evol-struct-pop-2021_xlsx.zip"
zip_path_activite_reside <- "data/raw/base-ic-activite-residents-2021_xlsx (1).zip"
zip_path_act5 <- "data/raw/TD_ACT5_2021_xlsx.zip"
raw_pop_structure <- import_xlsx_from_zip(zip_path_pop_structure)
raw_ic_activite <- import_xlsx_from_zip(zip_path_activite_reside)
raw_act5 <- import_xlsx_from_zip(zip_path_act5, skip = 9) %>% rename_to_com()
# 2.1 Préparation des données Egapro
egapro_prepared <- prepare_egapro_data(raw_egapro)
# 2.2 Nettoyage des données SIRENE (conservation des sièges sociaux)
sirene_clean <- clean_sirene_data(raw_sirene)
# 2.3 Calcul des indicateurs socio-démographiques au niveau communal
communes_features <- create_socio_features(
df_pop_structure = raw_pop_structure,
df_ic = raw_ic_activite,
df_act5 = raw_act5
)
shiny::runApp()
knitr::opts_chunk$set(echo = TRUE, message = TRUE, warning = TRUE)
# Librairies nécessaires pour ce script
library(dplyr)
library(sf)
library(stringr)
library(readxl)
library(janitor)
# Fonctions de préparation personnalisées
source("utils.R")
# 1.1 Egapro (via API data.gouv.fr)
raw_egapro <- import_latest_egapro()
# 1.2 SIRENE (via API Opendatasoft pour l'IDF)
raw_sirene <- import_sirene_idf()
# 1.3 Données du Recensement de la Population 2021 (INSEE)
message("--- Importation des données du Recensement (fichiers locaux) ---")
zip_path_pop_structure <- "data/raw/base-cc-evol-struct-pop-2021_xlsx.zip"
zip_path_activite_reside <- "data/raw/base-ic-activite-residents-2021_xlsx (1).zip"
zip_path_act5 <- "data/raw/TD_ACT5_2021_xlsx.zip"
raw_pop_structure <- import_xlsx_from_zip(zip_path_pop_structure)
raw_ic_activite <- import_xlsx_from_zip(zip_path_activite_reside)
raw_act5 <- import_xlsx_from_zip(zip_path_act5, skip = 9) %>% rename_to_com()
# 2.1 Préparation des données Egapro
egapro_prepared <- prepare_egapro_data(raw_egapro)
# 2.2 Nettoyage des données SIRENE (conservation des sièges sociaux)
sirene_clean <- clean_sirene_data(raw_sirene)
# 2.3 Calcul des indicateurs socio-démographiques au niveau communal
communes_features <- create_socio_features(
df_pop_structure = raw_pop_structure,
df_ic = raw_ic_activite,
df_act5 = raw_act5
)
View(aggregate_map)
knitr::opts_chunk$set(echo = TRUE, message = TRUE, warning = TRUE)
# Librairies nécessaires pour ce script
library(dplyr)
library(sf)
library(stringr)
library(readxl)
# Fonctions de préparation personnalisées
source("utils.R")
# 1.1 Egapro (via API data.gouv.fr)
raw_egapro <- import_latest_egapro()
# 1.2 SIRENE (via API Opendatasoft pour l'IDF)
raw_sirene <- import_sirene_idf()
# 1.3 Données du Recensement de la Population 2021 (INSEE)
message("--- Importation des données du Recensement (fichiers locaux) ---")
zip_path_pop_structure <- "data/raw/base-cc-evol-struct-pop-2021_xlsx.zip"
zip_path_activite_reside <- "data/raw/base-ic-activite-residents-2021_xlsx (1).zip"
zip_path_act5 <- "data/raw/TD_ACT5_2021_xlsx.zip"
raw_pop_structure <- import_xlsx_from_zip(zip_path_pop_structure)
raw_ic_activite <- import_xlsx_from_zip(zip_path_activite_reside)
raw_act5 <- import_xlsx_from_zip(zip_path_act5, skip = 9) %>% rename_to_com()
# 2.1 Préparation des données Egapro
egapro_prepared <- prepare_egapro_data(raw_egapro)
# 2.2 Nettoyage des données SIRENE (conservation des sièges sociaux)
sirene_clean <- clean_sirene_data(raw_sirene)
# 2.3 Calcul des indicateurs socio-démographiques au niveau communal
communes_features <- create_socio_features(
df_pop_structure = raw_pop_structure,
df_ic = raw_ic_activite,
df_act5 = raw_act5
)
paris_commune_data <- communes_features %>% filter(code_commune == "75056")
if(nrow(paris_commune_data) > 0) {
codes_arrondissements <- sprintf("751%02d", 1:20)
paris_arrondissements_data <- paris_commune_data[rep(1, 20), ] %>%
mutate(code_commune = codes_arrondissements)
communes_features <- bind_rows(communes_features, paris_arrondissements_data)
}
# Chargement du fond de carte des communes depuis une source ouverte
map_com_prepared <- load_and_prepare_map()
master_df_historique <- egapro_prepared %>%
# Jointure avec SIRENE pour la localisation
inner_join(sirene_clean, by = "siren") %>%
# Jointure avec les attributs du fond de carte pour récupérer les infos EPT/DEP
inner_join(st_drop_geometry(map_com_prepared), by = c("code_commune" = "com_code")) %>%
# Jointure avec les indicateurs socio-démographiques
left_join(communes_features, by = "code_commune")
message(
"✅ Table 'master_df_historique' finale créée avec ",
scales::comma(nrow(master_df_historique)), " observations."
)
output_dir <- "data_shiny"
if (!dir.exists(output_dir)) dir.create(output_dir)
# 5.1 Sauvegarde de la table de données principale
saveRDS(master_df_historique, file.path(output_dir, "master_df_historique.RDS"))
# 5.2 Sauvegarde des fonds de carte (communes et agrégés)
saveRDS(map_com_prepared, file.path(output_dir, "map_com.RDS"))
map_ept_prepared <- aggregate_map(map_com_prepared, level = "ept")
saveRDS(map_ept_prepared, file.path(output_dir, "map_ept.RDS"))
map_dep_prepared <- aggregate_map(map_com_prepared, level = "dep")
saveRDS(map_dep_prepared, file.path(output_dir, "map_dep.RDS"))
message("✅ Tous les fichiers ont été sauvegardés dans le dossier '", output_dir, "'.")
shiny::runApp()
shiny::runApp()
runApp()
runApp()
runApp()
runApp()
shiny::runApp()
runApp()
shiny::runApp()
getwd()
file.exists("modules/carte_module.R")
source("modules/carte_module.R", local = TRUE)
exists("carte_ui")
# ------------------------------------------------------------------------------
# 4. Objets statiques globaux
# ------------------------------------------------------------------------------
palette_accessible <- c("#E69F00", "#56B4E9", "#009E73", "#F0E442", "#0072B2", "#D55E00", "#CC79A7")
print("--- BLOC 1 : LIBRAIRIES ---")
library(shiny)
library(shinythemes)
# ==============================================================================
# global.R : Configuration et chargement des données
# Ce fichier est exécuté UNE SEULE FOIS au démarrage de l'application.
# ==============================================================================
# ------------------------------------------------------------------------------
# 1. Chargement des librairies
# ------------------------------------------------------------------------------
print("--- BLOC 1 : LIBRAIRIES ---")
library(shiny)
library(shinythemes)
library(sf)
library(leaflet)
library(dplyr)
library(ggplot2)
library(DT)
library(htmltools)
library(scales)
library(stringr)
library(ggrepel)
library(tidyr)
library(RColorBrewer)
library(plotly)
library(shinyWidgets)
library(jsonlite)
library(viridis)
library(shinydashboard)
print("--- BLOC 1 : OK ---")
# ------------------------------------------------------------------------------
# 2. Chargement des sources (fonctions et modules)
# ------------------------------------------------------------------------------
print("Chargement de global.R...") # Ligne de débogage
print("--- BLOC 2 : SOURCES ---")
source("utils.R", local = TRUE)
source("documentation.R", local = TRUE)
source("modules/carte_module.R", local = TRUE)
source("modules/sectoriel_module.R", local = TRUE)
source("modules/socio_dem_module.R", local = TRUE)
source("modules/historique_module.R", local = TRUE)
print("--- BLOC 2 : OK ---")
# ------------------------------------------------------------------------------
# 3. Chargement et préparation des données
# ------------------------------------------------------------------------------
print("--- BLOC 3 : DONNÉES ---")
# -- Alias --
validate <- shiny::validate
need     <- shiny::need
# -- Données --
master_df_historique <- readRDS("data_shiny/master_df_historique.RDS")
map_ept <- readRDS("data_shiny/map_ept.RDS")
map_dep <- readRDS("data_shiny/map_dep.RDS")
# -- Pré-calculs --
map_ept <- st_transform(map_ept, crs = 4326)
map_dep <- st_transform(map_dep, crs = 4326)
eff_key <- c("50 à 250" = 150, "251 à 999" = 625, "1000 et plus" = 1500)
master_df_historique <- master_df_historique %>%
mutate(poids = eff_key[tranche_effectifs] %>% unname())
print("--- BLOC 3 : OK ---")
# ------------------------------------------------------------------------------
# 4. Objets statiques globaux
# ------------------------------------------------------------------------------
palette_accessible <- c("#E69F00", "#56B4E9", "#009E73", "#F0E442", "#0072B2", "#D55E00", "#CC79A7")
socio_variable_labels <- c(
"part_femmes_cadres"        = "Part de femmes cadres parmi les femmes actives (%)",
"part_femmes_prof_inter"    = "Part de femmes en prof. inter. parmi les femmes actives (%)",
"taux_femmes_parmi_cadres"  = "Taux de féminisation des postes de cadres (%)",
"taux_activite_femmes"      = "Taux d'activité des femmes 15-64 ans (%)"
)
runApp()
runApp()
runApp()
runApp()
shiny::runApp()
shiny::runApp()
runApp()
runApp()
runApp()
runApp()
runApp()
runApp()
rm(list = ls())
exists("carte_ui")
runApp()
knitr::opts_chunk$set(echo = TRUE, message = TRUE, warning = TRUE)
# Librairies nécessaires pour ce script
library(dplyr)
library(sf)
library(stringr)
library(readxl)
# Fonctions de préparation personnalisées
source("utils.R")
# 1.1 Egapro (via API data.gouv.fr)
raw_egapro <- import_latest_egapro()
# 1.2 SIRENE (via API Opendatasoft pour l'IDF)
raw_sirene <- import_sirene_idf()
# 1.3 Données du Recensement de la Population 2021 (INSEE)
message("--- Importation des données du Recensement (fichiers locaux) ---")
zip_path_pop_structure <- "data/raw/base-cc-evol-struct-pop-2021_xlsx.zip"
zip_path_activite_reside <- "data/raw/base-ic-activite-residents-2021_xlsx (1).zip"
zip_path_act5 <- "data/raw/TD_ACT5_2021_xlsx.zip"
raw_pop_structure <- import_xlsx_from_zip(zip_path_pop_structure)
raw_ic_activite <- import_xlsx_from_zip(zip_path_activite_reside)
raw_act5 <- import_xlsx_from_zip(zip_path_act5, skip = 9) %>% rename_to_com()
# 1.1 Egapro (via API data.gouv.fr)
raw_egapro <- import_latest_egapro()
# 1.2 SIRENE (via API Opendatasoft pour l'IDF)
raw_sirene <- import_sirene_idf()
# 1.3 Données du Recensement de la Population 2021 (INSEE)
message("--- Importation des données du Recensement (fichiers locaux) ---")
zip_path_pop_structure <- "data/raw/base-cc-evol-struct-pop-2021_xlsx.zip"
zip_path_activite_reside <- "data/raw/base-ic-activite-residents-2021_xlsx (1).zip"
zip_path_act5 <- "data/raw/TD_ACT5_2021_xlsx.zip"
raw_pop_structure <- import_xlsx_from_zip(zip_path_pop_structure)
raw_ic_activite <- import_xlsx_from_zip(zip_path_activite_reside)
raw_act5 <- import_xlsx_from_zip(zip_path_act5, skip = 9) %>% rename_to_com()
runApp()
runApp()
runApp()
runApp()
runApp()
runApp()
# -- Alias --
validate <- shiny::validate
runApp()
runApp()
runApp()
runApp()
listfiles
list.files()
runApp()
